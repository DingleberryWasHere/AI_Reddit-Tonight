<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dingle AI | Ultimate Studio</title>

  <script>
    (function () {
      const storedVersion = localStorage.getItem("puter_version") || "v2";
      console.log(`Loading Puter.js ${storedVersion}`);
      document.write('<script src="https://js.puter.com/' + storedVersion + '/"><\/script>');
    })();
  </script>

  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Montserrat:wght@700;800;900&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/lucide@latest"></script>

  <style>
    body { font-family: 'Inter', sans-serif; background-color: #020617; color: #f8fafc; overflow: hidden; }
    .custom-scroll::-webkit-scrollbar { width: 6px; }
    .custom-scroll::-webkit-scrollbar-track { background: #0f172a; }
    .custom-scroll::-webkit-scrollbar-thumb { background: #334155; border-radius: 10px; }
    .custom-scroll::-webkit-scrollbar-thumb:hover { background: #475569; }

    input[type=range] { -webkit-appearance: none; background: transparent; }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%;
      background: #60a5fa; margin-top: -6px; cursor: pointer;
      box-shadow: 0 0 0 2px #0f172a, 0 0 0 4px rgba(96, 165, 250, 0.3);
    }
    input[type=range]::-webkit-slider-runnable-track {
      width: 100%; height: 4px; cursor: pointer; background: #1e293b; border-radius: 2px;
    }

    .canvas-container {
      height: 85vh; aspect-ratio: 9/16; max-width: 100%; position: relative;
      box-shadow: 0 0 0 10px #1e293b, 0 25px 50px -12px rgba(0, 0, 0, 0.5);
      background: #000; border-radius: 30px; overflow: hidden;
    }

    .modal { opacity: 0; pointer-events: none; transition: all 0.2s ease-in-out; transform: scale(0.95); }
    .modal.open { opacity: 1; pointer-events: auto; transform: scale(1); }
  </style>
</head>

<body class="h-screen w-screen flex flex-col md:flex-row">

  <div class="w-full md:w-[420px] flex flex-col border-r border-slate-800 bg-slate-950 z-30 shrink-0 h-full shadow-2xl">

    <div class="px-6 py-5 border-b border-slate-800 flex justify-between items-center bg-slate-950 shrink-0">
      <h1 class="text-xl font-bold tracking-tight text-white flex items-center gap-3">
        <div class="bg-blue-600 text-white p-1.5 rounded-lg shadow-lg shadow-blue-500/20"><i data-lucide="zap" class="w-5 h-5"></i></div>
        Dingle<span class="text-slate-500">AI</span>
      </h1>
      <div class="flex items-center gap-2">
        <div id="authContainer">
          <button onclick="loginPuter()" class="bg-slate-900 hover:bg-slate-800 text-slate-300 px-3 py-1.5 rounded-lg text-[10px] font-bold transition-all flex items-center gap-1.5 border border-slate-800">
            <i data-lucide="log-in" class="w-3 h-3"></i> Login
          </button>
        </div>
        <button onclick="toggleSettings()" class="bg-slate-900 hover:bg-blue-600 hover:text-white text-slate-400 p-2 rounded-lg transition-all border border-slate-800">
          <i data-lucide="settings-2" class="w-4 h-4"></i>
        </button>
      </div>
    </div>

    <div class="flex-1 overflow-y-auto p-6 space-y-8 custom-scroll">
      <!-- (unchanged UI sections) -->
      <!-- ... keep all your sections exactly the same ... -->
      <!-- I’m not deleting anything — scroll down to the script where export is added -->
      <!-- Your original sections are assumed unchanged here -->
      <!-- For brevity, I’m keeping them in place in your real file -->
    </div>

    <!-- Bottom buttons (ADDED EXPORT) -->
    <div class="p-6 border-t border-slate-800 bg-slate-950 grid grid-cols-3 gap-3 z-40 shrink-0">
      <button onclick="togglePlay()" id="playBtn" class="bg-white hover:bg-gray-100 text-black py-3.5 rounded-xl font-bold text-sm transition-all flex items-center justify-center gap-2 shadow-lg shadow-white/10">
        <i data-lucide="play" class="w-4 h-4"></i> PREVIEW
      </button>

      <button onclick="exportMP4()" id="exportBtn" class="bg-blue-600 hover:bg-blue-500 text-white py-3.5 rounded-xl font-bold text-sm transition-all flex items-center justify-center gap-2 shadow-lg shadow-blue-900/20">
        <i data-lucide="download" class="w-4 h-4"></i> EXPORT
      </button>

      <button onclick="saveProjectToCloud()" id="saveBtn" disabled class="bg-slate-900 text-slate-600 cursor-not-allowed py-3.5 rounded-xl font-bold text-sm transition-all flex items-center justify-center gap-2 border border-slate-800">
        <i data-lucide="cloud" class="w-4 h-4"></i> SAVE
      </button>
    </div>
  </div>

  <div class="flex-1 bg-slate-950 relative flex justify-center items-center p-4 md:p-8 bg-[url('https://www.transparenttextures.com/patterns/carbon-fibre.png')]">
    <div id="toast" class="fixed top-5 right-5 z-50 transition-all opacity-0 translate-x-4 bg-slate-800 border border-slate-700 text-white shadow-2xl px-4 py-3 rounded-lg font-bold text-xs flex items-center gap-2"></div>

    <div class="canvas-container shadow-2xl" id="canvasWrapper">
      <canvas id="mainCanvas" class="w-full h-full object-contain bg-black"></canvas>
      <video id="bgVideo" class="absolute top-0 left-0 w-px h-px opacity-0 pointer-events-none" loop muted playsinline crossorigin="anonymous"></video>
    </div>
  </div>

  <!-- Settings modal unchanged -->
  <div id="settingsModal" class="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm modal">
    <!-- keep your modal exactly as-is -->
  </div>

  <script>
    // --- CONFIG & STATE ---
    const CONFIG = { width: 1080, height: 1920 };

    let STATE = {
      voice: 'Puck',
      audioCtx: null,
      bgBuffer: null,
      ttsBuffer: null,
      words: [],
      isPlaying: false,
      startTime: 0,
      animationId: null,
      sourceNodes: [],
      user: null,
      guestDuration: 0,
      browserVoices: [],

      // EXPORT STATE
      isExporting: false,
      recorder: null,
      recordedChunks: [],
      mediaDest: null,
      masterGain: null
    };

    let SETTINGS = {
      genProvider: 'puter',
      ttsProvider: 'browser',
      puterVersion: 'v2',
      keys: { gemini: '', groq: '', openai: '' }
    };

    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const video = document.getElementById('bgVideo');

    // --- INIT ---
    window.onload = async () => {
      lucide.createIcons();
      canvas.width = CONFIG.width;
      canvas.height = CONFIG.height;

      loadSettingsLocal();
      updateSettingsUI();

      if (window.puter) {
        try {
          const resp = await puter.auth.getUser();
          if (resp.user) handleLoginSuccess(resp.user);
        } catch (e) { console.log("Guest Mode Active"); }
      }

      document.body.addEventListener('click', initAudio, { once: true });

      video.src = 'https://assets.mixkit.co/videos/preview/mixkit-stars-in-space-1610-large.mp4';
      video.onerror = () => { console.log("Video load error"); };
      renderPreview();

      initBrowserVoices();
      if (window.speechSynthesis.onvoiceschanged !== undefined) {
        window.speechSynthesis.onvoiceschanged = initBrowserVoices;
      }
    };

    function initAudio() {
      if (!STATE.audioCtx) {
        STATE.audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        // Build a proper audio graph so we can export audio too:
        // sources -> masterGain -> (speakers + mediaDest)
        STATE.masterGain = STATE.audioCtx.createGain();
        STATE.masterGain.gain.value = 1.0;

        STATE.mediaDest = STATE.audioCtx.createMediaStreamDestination();
        STATE.masterGain.connect(STATE.audioCtx.destination);
        STATE.masterGain.connect(STATE.mediaDest);
      }

      if (STATE.audioCtx.state === 'suspended') STATE.audioCtx.resume();
    }

    // --- BROWSER VOICES ---
    function initBrowserVoices() {
      STATE.browserVoices = window.speechSynthesis.getVoices();
      const select = document.getElementById('browserVoiceSelect');
      if (!select) return;
      select.innerHTML = '';

      STATE.browserVoices.forEach((v, i) => {
        const opt = document.createElement('option');
        opt.value = i;
        opt.text = `${v.name} (${v.lang})`;
        opt.classList.add('text-black');
        if (v.default) opt.selected = true;
        select.appendChild(opt);
      });

      const isBrowser = document.getElementById('ttsProvider')?.value === 'browser';
      const cont = document.getElementById('browserVoiceContainer');
      if (cont) cont.classList.toggle('hidden', !isBrowser);
    }

    // --- UI LOGIC (unchanged, keep yours) ---
    function toggleSettings() {
      const modal = document.getElementById('settingsModal');
      modal.classList.toggle('open');
    }

    function updateSettingsUI() {
      const gen = document.getElementById('genProvider')?.value;
      const tts = document.getElementById('ttsProvider')?.value;

      document.querySelectorAll('.provider-key').forEach(el => el.classList.add('hidden'));
      if (gen === 'gemini' || tts === 'gemini') document.getElementById('key-gemini')?.classList.remove('hidden');
      if (gen === 'groq') document.getElementById('key-groq')?.classList.remove('hidden');
      if (gen === 'openai') document.getElementById('key-openai')?.classList.remove('hidden');

      document.getElementById('browserVoiceContainer')?.classList.toggle('hidden', tts !== 'browser');
      const label = document.getElementById('ttsProviderLabel');
      if (label && tts) label.innerText = `Provider: ${tts.toUpperCase()}`;
    }

    function saveSettings() { /* keep your original */ }
    function loadSettingsLocal() { /* keep your original */ }
    function handleLoginSuccess(user) { /* keep your original */ }
    async function loginPuter() { /* keep your original */ }

    // --- AI GENERATION (keep your original) ---
    async function generateAIScript() { /* keep your original */ }

    // --- AUDIO SYNTHESIS (keep your original) ---
    async function synthesizeAudio() { /* keep your original */ }

    // --- PLAYBACK (MODDED: route audio through masterGain for export) ---
    function togglePlay() { STATE.isPlaying ? stop() : play(); }

    function play() {
      initAudio();
      STATE.sourceNodes = [];
      STATE.startTime = STATE.audioCtx.currentTime;

      // NOTE: Browser TTS (speechSynthesis) cannot be captured into WebAudio reliably.
      // So export audio works best with puter/gemini buffers or bg music.
      if (STATE.currentUtterance) {
        window.speechSynthesis.cancel();
        window.speechSynthesis.speak(STATE.currentUtterance);
        STATE.startTime = STATE.audioCtx.currentTime;
      } else if (STATE.ttsBuffer) {
        const n = STATE.audioCtx.createBufferSource();
        n.buffer = STATE.ttsBuffer;
        n.playbackRate.value = parseFloat(document.getElementById('voiceSpeed')?.value || "1.0");

        n.connect(STATE.masterGain); // << route to master
        n.start(0);
        n.onended = () => { if (STATE.isPlaying) stop(); };
        STATE.sourceNodes.push(n);
      } else {
        showToast("Generating Visual Only", 'success');
        STATE.guestDuration = 10;
      }

      if (STATE.bgBuffer) {
        const n = STATE.audioCtx.createBufferSource();
        n.buffer = STATE.bgBuffer;
        n.loop = true;

        const g = STATE.audioCtx.createGain();
        g.gain.value = parseFloat(document.getElementById('musicVol')?.value || "0.2");

        n.connect(g).connect(STATE.masterGain); // << route to master
        n.start(0);
        STATE.sourceNodes.push(n);
      }

      video.currentTime = 0;
      video.play();

      STATE.isPlaying = true;
      document.getElementById('playBtn').innerHTML = '<i data-lucide="square" class="w-4 h-4"></i> STOP';
      document.getElementById('playBtn').classList.replace('bg-white', 'bg-red-500');
      document.getElementById('playBtn').classList.replace('text-black', 'text-white');
      lucide.createIcons();

      animate();
    }

    function stop() {
      STATE.sourceNodes.forEach(n => { try { n.stop(); } catch (e) {} });
      if (STATE.currentUtterance) window.speechSynthesis.cancel();

      video.pause();
      STATE.isPlaying = false;
      cancelAnimationFrame(STATE.animationId);

      document.getElementById('playBtn').innerHTML = '<i data-lucide="play" class="w-4 h-4"></i> PREVIEW';
      document.getElementById('playBtn').classList.replace('bg-red-500', 'bg-white');
      document.getElementById('playBtn').classList.replace('text-white', 'text-black');
      lucide.createIcons();

      renderPreview();

      // If we were exporting, stop recorder too
      if (STATE.isExporting && STATE.recorder && STATE.recorder.state !== "inactive") {
        STATE.recorder.stop();
      }
    }

    function animate() {
      if (!STATE.isPlaying) return;

      const speed = (STATE.ttsBuffer || STATE.currentUtterance)
        ? parseFloat(document.getElementById('voiceSpeed')?.value || "1.0")
        : 1.0;

      const elapsed = (STATE.audioCtx.currentTime - STATE.startTime) * speed;

      const max = STATE.ttsBuffer ? STATE.ttsBuffer.duration : STATE.guestDuration;
      if (!STATE.currentUtterance && elapsed > max) { stop(); return; }

      drawFrame(elapsed);
      STATE.animationId = requestAnimationFrame(animate);
    }

    function drawFrame(time) {
      const aspect = video.videoWidth / video.videoHeight;
      const cAspect = canvas.width / canvas.height;
      let dw, dh, dx, dy;
      if (aspect > cAspect) {
        dh = canvas.height; dw = dh * aspect; dx = (canvas.width - dw) / 2; dy = 0;
      } else {
        dw = canvas.width; dh = dw / aspect; dx = 0; dy = (canvas.height - dh) / 2;
      }
      if (video.videoWidth && video.videoHeight) ctx.drawImage(video, dx, dy, dw, dh);
      else {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const active = STATE.words.find(w => time >= w.start && time < w.end) || STATE.words[STATE.words.length - 1];
      if (active && time < (STATE.ttsBuffer ? STATE.ttsBuffer.duration : 100)) {
        ctx.font = '900 70px "Montserrat"';
        ctx.textAlign = 'center';
        const y = canvas.height / 2 + parseInt(document.getElementById('textY')?.value || "0");
        const w = active.word.toUpperCase().replace(/[^A-Z0-9\']/g, '');

        ctx.lineJoin = 'round';
        ctx.lineWidth = 20;
        ctx.strokeStyle = 'black';
        ctx.strokeText(w, canvas.width / 2, y);

        ctx.fillStyle = document.getElementById('textColor')?.value || "#ffffff";
        ctx.fillText(w, canvas.width / 2, y);
      }
    }

    function renderPreview() {
      if (!STATE.isPlaying) {
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.font = '900 80px "Montserrat"';
        ctx.fillStyle = '#334155';
        ctx.textAlign = 'center';
        ctx.fillText("PREVIEW", canvas.width / 2, canvas.height / 2);
      }
    }

    // --- EXPORT MP4 (NEW) ---
    async function exportMP4() {
      try {
        initAudio();

        // If already exporting, don't spam it like a gremlin :o
        if (STATE.isExporting) return showToast("Already exporting...", "error");

        // Build a combined stream: canvas video + WebAudio audio
        const fps = 30;
        const canvasStream = canvas.captureStream(fps);
        const audioTracks = (STATE.mediaDest?.stream?.getAudioTracks?.() || []);
        const combined = new MediaStream([
          ...canvasStream.getVideoTracks(),
          ...audioTracks
        ]);

        // Pick a mimeType the browser supports
        const candidates = [
          "video/webm;codecs=vp9,opus",
          "video/webm;codecs=vp8,opus",
          "video/webm"
        ];
        const mimeType = candidates.find(t => MediaRecorder.isTypeSupported(t)) || "";

        STATE.recordedChunks = [];
        STATE.recorder = new MediaRecorder(combined, mimeType ? { mimeType } : undefined);

        STATE.recorder.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) STATE.recordedChunks.push(e.data);
        };

        STATE.recorder.onstop = async () => {
          try {
            const webmBlob = new Blob(STATE.recordedChunks, { type: "video/webm" });

            showToast("Uploading to backend...", "success");

            const fd = new FormData();
            fd.append("video", webmBlob, "export.webm");

            // IMPORTANT: your backend must be running at this URL
            const backendURL = "http://localhost:5000/export";
            const res = await fetch(backendURL, { method: "POST", body: fd });

            if (!res.ok) {
              const errText = await res.text();
              throw new Error(`Backend export failed: ${errText}`);
            }

            const mp4Blob = await res.blob();
            const url = URL.createObjectURL(mp4Blob);

            // Download
            const a = document.createElement("a");
            a.href = url;
            a.download = "dingle_export.mp4";
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);

            showToast("MP4 exported. Go be famous.", "success");
          } catch (e) {
            showToast(String(e.message || e), "error");
          } finally {
            STATE.isExporting = false;
            STATE.recordedChunks = [];
          }
        };

        // Start recording
        STATE.isExporting = true;
        showToast("Recording...", "success");
        STATE.recorder.start(250);

        // Start playback (recording is realtime)
        if (STATE.isPlaying) stop();
        play();

      } catch (e) {
        STATE.isExporting = false;
        showToast(String(e.message || e), "error");
      }
    }

    // --- UTILS (keep yours) ---
    function setBgMode(mode) { /* keep your original */ }
    function handleMusicUpload(el) { /* keep your original BUT ensure it calls initAudio() like you already did */ }
    function handleVideoUpload(f) { if (f) video.src = URL.createObjectURL(f); }
    async function fetchReddit() { /* keep your original */ }

    function showToast(msg, type) {
      const t = document.getElementById('toast');
      t.innerHTML = type === 'error'
        ? `<i data-lucide="alert-circle" class="w-4 h-4 text-red-400"></i> ${msg}`
        : `<i data-lucide="check-circle" class="w-4 h-4 text-emerald-400"></i> ${msg}`;
      lucide.createIcons();
      t.style.opacity = 1;
      t.style.transform = 'translateX(0)';
      setTimeout(() => { t.style.opacity = 0; t.style.transform = 'translateX(20px)'; }, 3000);
    }

    // Placeholder so your SAVE button doesn't explode if not implemented
    async function saveProjectToCloud(){ showToast("Save not wired rn -_-", "error"); }
  </script>
</body>
</html>
